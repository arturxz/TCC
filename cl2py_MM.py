
"""
    ************************************************************************
    ***                                                                  ***
    ***                Source code generated by cl2py.pl                 ***
    ***                                                                  ***
    ***                        Please do not edit                        ***
    ***                                                                  ***
    ************************************************************************
"""
#!/usr/bin/python3 python3

# OPENCL LIBRARY
import pyopencl as cl

# VGL LIBRARYS
import vgl_lib as vl

#TO WORK WITH MAIN
import numpy as np

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyAlgDilate(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyAlgDilate.cl", "vglCl3dFuzzyAlgDilate")
    _kernel = _program.vglCl3dFuzzyAlgDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyAlgErode(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyAlgErode.cl", "vglCl3dFuzzyAlgErode")
    _kernel = _program.vglCl3dFuzzyAlgErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyArithDilate(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyArithDilate.cl", "vglCl3dFuzzyArithDilate")
    _kernel = _program.vglCl3dFuzzyArithDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyArithErode(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyArithErode.cl", "vglCl3dFuzzyArithErode")
    _kernel = _program.vglCl3dFuzzyArithErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyBoundDilate(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyBoundDilate.cl", "vglCl3dFuzzyBoundDilate")
    _kernel = _program.vglCl3dFuzzyBoundDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyBoundErode(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyBoundErode.cl", "vglCl3dFuzzyBoundErode")
    _kernel = _program.vglCl3dFuzzyBoundErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyDaPDilate(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z, gama):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF gama IS IN CORRECT TYPE
    if( not isinstance(gama, np.float32) ):
        print("vglClConvolution: Warning: gama not np.float32! Trying to convert...")
        try:
            gama = np.float32(gama)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert gama as a np.float32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyDaPDilate.cl", "vglCl3dFuzzyDaPDilate")
    _kernel = _program.vglCl3dFuzzyDaPDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)
    _kernel.set_arg(6, gama)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyDaPErode(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z, gama):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF gama IS IN CORRECT TYPE
    if( not isinstance(gama, np.float32) ):
        print("vglClConvolution: Warning: gama not np.float32! Trying to convert...")
        try:
            gama = np.float32(gama)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert gama as a np.float32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyDaPErode.cl", "vglCl3dFuzzyDaPErode")
    _kernel = _program.vglCl3dFuzzyDaPErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)
    _kernel.set_arg(6, gama)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyDrasticDilate(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyDrasticDilate.cl", "vglCl3dFuzzyDrasticDilate")
    _kernel = _program.vglCl3dFuzzyDrasticDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyDrasticErode(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyDrasticErode.cl", "vglCl3dFuzzyDrasticErode")
    _kernel = _program.vglCl3dFuzzyDrasticErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyGeoDilate(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyGeoDilate.cl", "vglCl3dFuzzyGeoDilate")
    _kernel = _program.vglCl3dFuzzyGeoDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyGeoErode(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyGeoErode.cl", "vglCl3dFuzzyGeoErode")
    _kernel = _program.vglCl3dFuzzyGeoErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyHamacherDilate(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z, gama):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF gama IS IN CORRECT TYPE
    if( not isinstance(gama, np.float32) ):
        print("vglClConvolution: Warning: gama not np.float32! Trying to convert...")
        try:
            gama = np.float32(gama)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert gama as a np.float32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyHamacherDilate.cl", "vglCl3dFuzzyHamacherDilate")
    _kernel = _program.vglCl3dFuzzyHamacherDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)
    _kernel.set_arg(6, gama)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyHamacherErode(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z, gama):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF gama IS IN CORRECT TYPE
    if( not isinstance(gama, np.float32) ):
        print("vglClConvolution: Warning: gama not np.float32! Trying to convert...")
        try:
            gama = np.float32(gama)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert gama as a np.float32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyHamacherErode.cl", "vglCl3dFuzzyHamacherErode")
    _kernel = _program.vglCl3dFuzzyHamacherErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)
    _kernel.set_arg(6, gama)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyStdDilate(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyStdDilate.cl", "vglCl3dFuzzyStdDilate")
    _kernel = _program.vglCl3dFuzzyStdDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglCl3dFuzzyStdErode(img_input, img_output, convolution_window, window_size_x, window_size_y, window_size_z):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_z IS IN CORRECT TYPE
    if( not isinstance(window_size_z, np.uint32) ):
        print("vglClConvolution: Warning: window_size_z not np.uint32! Trying to convert...")
        try:
            window_size_z = np.uint32(window_size_z)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_z as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglCl3dFuzzyStdErode.cl", "vglCl3dFuzzyStdErode")
    _kernel = _program.vglCl3dFuzzyStdErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, window_size_z)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyAlgDilate(img_input, img_output, convolution_window, window_size_x, window_size_y):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyAlgDilate.cl", "vglClFuzzyAlgDilate")
    _kernel = _program.vglClFuzzyAlgDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyAlgErode(img_input, img_output, convolution_window, window_size_x, window_size_y):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyAlgErode.cl", "vglClFuzzyAlgErode")
    _kernel = _program.vglClFuzzyAlgErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyArithDilate(img_input, img_output, convolution_window, window_size_x, window_size_y):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyArithDilate.cl", "vglClFuzzyArithDilate")
    _kernel = _program.vglClFuzzyArithDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyArithErode(img_input, img_output, convolution_window, window_size_x, window_size_y):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyArithErode.cl", "vglClFuzzyArithErode")
    _kernel = _program.vglClFuzzyArithErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyBoundDilate(img_input, img_output, convolution_window, window_size_x, window_size_y):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyBoundDilate.cl", "vglClFuzzyBoundDilate")
    _kernel = _program.vglClFuzzyBoundDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyBoundErode(img_input, img_output, convolution_window, window_size_x, window_size_y):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyBoundErode.cl", "vglClFuzzyBoundErode")
    _kernel = _program.vglClFuzzyBoundErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyDaPDilate(img_input, img_output, convolution_window, window_size_x, window_size_y, gama):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF gama IS IN CORRECT TYPE
    if( not isinstance(gama, np.float32) ):
        print("vglClConvolution: Warning: gama not np.float32! Trying to convert...")
        try:
            gama = np.float32(gama)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert gama as a np.float32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyDaPDilate.cl", "vglClFuzzyDaPDilate")
    _kernel = _program.vglClFuzzyDaPDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, gama)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyDaPErode(img_input, img_output, convolution_window, window_size_x, window_size_y, gama):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF gama IS IN CORRECT TYPE
    if( not isinstance(gama, np.float32) ):
        print("vglClConvolution: Warning: gama not np.float32! Trying to convert...")
        try:
            gama = np.float32(gama)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert gama as a np.float32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyDaPErode.cl", "vglClFuzzyDaPErode")
    _kernel = _program.vglClFuzzyDaPErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, gama)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyDrasticDilate(img_input, img_output, convolution_window, window_size_x, window_size_y):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyDrasticDilate.cl", "vglClFuzzyDrasticDilate")
    _kernel = _program.vglClFuzzyDrasticDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyDrasticErode(img_input, img_output, convolution_window, window_size_x, window_size_y):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyDrasticErode.cl", "vglClFuzzyDrasticErode")
    _kernel = _program.vglClFuzzyDrasticErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyGeoDilate(img_input, img_output, convolution_window, window_size_x, window_size_y):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyGeoDilate.cl", "vglClFuzzyGeoDilate")
    _kernel = _program.vglClFuzzyGeoDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyGeoErode(img_input, img_output, convolution_window, window_size_x, window_size_y):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyGeoErode.cl", "vglClFuzzyGeoErode")
    _kernel = _program.vglClFuzzyGeoErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyHamacherDilate(img_input, img_output, convolution_window, window_size_x, window_size_y, gama):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF gama IS IN CORRECT TYPE
    if( not isinstance(gama, np.float32) ):
        print("vglClConvolution: Warning: gama not np.float32! Trying to convert...")
        try:
            gama = np.float32(gama)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert gama as a np.float32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyHamacherDilate.cl", "vglClFuzzyHamacherDilate")
    _kernel = _program.vglClFuzzyHamacherDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, gama)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyHamacherErode(img_input, img_output, convolution_window, window_size_x, window_size_y, gama):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF gama IS IN CORRECT TYPE
    if( not isinstance(gama, np.float32) ):
        print("vglClConvolution: Warning: gama not np.float32! Trying to convert...")
        try:
            gama = np.float32(gama)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert gama as a np.float32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyHamacherErode.cl", "vglClFuzzyHamacherErode")
    _kernel = _program.vglClFuzzyHamacherErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)
    _kernel.set_arg(5, gama)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyStdDilate(img_input, img_output, convolution_window, window_size_x, window_size_y):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyStdDilate.cl", "vglClFuzzyStdDilate")
    _kernel = _program.vglClFuzzyStdDilate

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.

  */    
"""
def vglClFuzzyStdErode(img_input, img_output, convolution_window, window_size_x, window_size_y):

    vl.vglCheckContext(img_input, vl.VGL_CL_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_CL_CONTEXT())
    # EVALUATING IF convolution_window IS IN CORRECT TYPE
    try:
        mobj_convolution_window = cl.Buffer(vl.get_ocl().context, cl.mem_flags.READ_ONLY, convolution_window.nbytes)
        cl.enqueue_copy(vl.get_ocl().commandQueue, mobj_convolution_window, convolution_window.tobytes(), is_blocking=True)
        convolution_window = mobj_convolution_window
    except Exception as e:
        print("vglClConvolution: Error!! Impossible to convert convolution_window to cl.Buffer object.")
        print(str(e))
        exit()
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        print("vglClConvolution: Warning: window_size_x not np.uint32! Trying to convert...")
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        print("vglClConvolution: Warning: window_size_y not np.uint32! Trying to convert...")
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglClConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()

    _program = vl.get_ocl_context().get_compiled_kernel("CL_MM/vglClFuzzyStdErode.cl", "vglClFuzzyStdErode")
    _kernel = _program.vglClFuzzyStdErode

    _kernel.set_arg(0, img_input.get_oclPtr())
    _kernel.set_arg(1, img_output.get_oclPtr())
    _kernel.set_arg(2, mobj_convolution_window)
    _kernel.set_arg(3, window_size_x)
    _kernel.set_arg(4, window_size_y)

    # THIS IS A BLOCKING COMMAND. IT EXECUTES THE KERNEL.
    cl.enqueue_nd_range_kernel(vl.get_ocl().commandQueue, _kernel, img_input.get_oclPtr().shape, None)

    mobj_convolution_window = None
    vl.vglSetContext(img_output, vl.VGL_CL_CONTEXT())

